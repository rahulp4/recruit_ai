# database/job_profile_match_repository.py

import logging
import json
import uuid # For UUID generation
from sqlalchemy import text
from database.postgres_manager import get_db_session
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)
# logger.setLevel(logging.INFO)

class JobProfileMatchRepository:
    """
    Data Access Layer for Job-Profile Match entities.
    Handles interaction with the 'job_profile_match' table.
    """
    def __init__(self):
        logger.info("JobProfileMatchRepository initialized.")

    def save_match_result(self,
                          job_id: int,
                          profile_id: int,
                          candidate_name: str,
                          overall_score: float,
                          match_results_json: Dict[str, Any],
                          organization_id: str,
                          created_by: str,
                          agency_id: Optional[str] = None) -> str: # Returns the UUID
        """
        Saves a job-profile match result to the database.
        """
        session = get_db_session()
        try:
            # UUID is generated by DB default (uuid_generate_v4())
            match_results_json_str = json.dumps(match_results_json)

            query = text("""
                INSERT INTO job_profile_match (job_id, profile_id, candidate_name, overall_score, match_results_json, organization_id, agency_id, created_by)
                VALUES (:job_id, :profile_id, :candidate_name, :overall_score, :match_results_json, :organization_id, :agency_id, :created_by)
                RETURNING id;
            """)
            
            result = session.execute(query, {
                'job_id': job_id,
                'profile_id': profile_id,
                'candidate_name': candidate_name,
                'overall_score': overall_score,
                'match_results_json': match_results_json_str,
                'organization_id': organization_id,
                'agency_id': agency_id,
                'created_by': created_by
            })
            
            match_id = result.scalar_one() # This will be the UUID
            session.commit()
            logger.info(f"Match result saved with ID: {match_id} for Job ID {job_id}, Profile ID {profile_id}.")
            return str(match_id) # Return UUID as string
        except Exception as e:
            session.rollback()
            logger.error(f"Error saving match result for Job {job_id}, Profile {profile_id}: {e}", exc_info=True)
            raise
        finally:
            session.close()

    def search_matches(self,
                       job_id: Optional[int] = None,
                       candidate_name: Optional[str] = None,
                       organization_id: Optional[str] = None,
                       limit: int = 100,
                       order_by_score_desc: bool = True) -> List[Dict[str, Any]]:
        """
        Searches for job-profile match results based on criteria.
        """
        session = get_db_session()
        try:
            where_clauses = []
            params = {}

            if job_id is not None:
                where_clauses.append("job_id = :job_id")
                params['job_id'] = job_id
            
            if candidate_name:
                where_clauses.append("candidate_name ILIKE :candidate_name")
                params['candidate_name'] = f"%{candidate_name}%"
            
            if organization_id:
                where_clauses.append("organization_id = :organization_id")
                params['organization_id'] = organization_id

            sql_query = """
                SELECT id, job_id, profile_id, candidate_name, overall_score, match_results_json, organization_id, agency_id, created_by, created_at
                FROM job_profile_match
            """
            if where_clauses:
                sql_query += " WHERE " + " AND ".join(where_clauses)
            
            if order_by_score_desc:
                sql_query += " ORDER BY overall_score DESC"
            else:
                sql_query += " ORDER BY overall_score ASC"
            
            sql_query += " LIMIT :limit;"
            params['limit'] = limit

            results = session.execute(text(sql_query), params).fetchall()

            matches = []
            for row in results:
                matches.append({
                    "id": str(row.id), # UUID as string
                    "jobId": row.job_id,
                    "profileId": row.profile_id,
                    "candidateName": row.candidate_name,
                    "overallScore": float(row.overall_score), # Convert from Numeric
                    "matchResultsJson": row.match_results_json, # Already dict from JSONB
                    "organizationId": row.organization_id,
                    "agencyId": row.agency_id,
                    "createdBy": row.created_by,
                    "createdAt": row.created_at.isoformat()
                })
            logger.info(f"Found {len(matches)} match results for search criteria: {params}.")
            return matches
        except Exception as e:
            session.rollback()
            logger.error(f"Error searching match results with criteria {params}: {e}", exc_info=True)
            raise
        finally:
            session.close()